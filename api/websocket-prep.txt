- Connect to organizations endpoint
- Connect to badges endpoint

- Just filter the websocket responses on the front end

- websockets do not have kwarg urls which means we should not specifically connect to org/<id>/
- to accomplish something similiar, one would emit a 'subscribe' request to the socket with the id in the payload

- still, it is probably "better" to not do it like this and take the shortcut route as that also means we can update everything in the background
- then, on an organization page it is just a matter of filtering the data down to the relevant id

- have to figure out how to get the authenticated passed in with websockets, but given credentialed APIs and the django-native implementation of authentication now, this should not require a custom solution; although creative.

- the api is already setup to only return organizations and badges that a user has permission to view / edit.
    - there are likely some changes needed here 

- Did we "have" to send the disconnect event?
    - when is a connection terminated if we do not expect a disconnect
        - how do we handle the forced refresh and socket wipe if a user just wants to be on the page for an extended period?
            - the obvious answer is we send the disconnect 

- under all costs, we will avoid permission level serializers, permissions of a single unified serializer MUST be maintained.

- we can create a consumer that fires updates for the relevant queryset any time the model is updated
    - this means that even if the indexer updates in the background, then everything, everywhere will be updated

- there are a lot of landmines with websockets, the ideal process of development is:
    1. get backend running
    2. get websocket connected
    3. get frontend connected
    4. output shape
    5. mold shape
    6. integrate into real page
        - it is critical this be saved until the last bit, the data shape of websockets often makes no sense and leads to too much work

- normally, it would be advised not to worry about authentication however because it is a key piece of badger and is also being used to handle the result filtering, authentication will have to be handled as the first step of front end integration.
    - we have a custom implementation the odds are low that we will get by without a custom handler.

- the key debt + changes needed:
    - contexts
    - errors
    - buttons
    - form submissions

- when contexts are changed, all other pages will be broken which means the app will be hard grid locked.
- will have to start at the home page and work deeper

- right now errors are page specific and will result in significant issues
- `useSocket.send` is used to transmit data back home
- to connect with authentication, the login request will still be made through http. we are not connecting people to a user pool

- CHANCE: conquering the world:
    - fix the project file architecture, it is killing me.
        - abis
        - components: ONLY COMPONENTS
        - pages: ONLY PAGES
        - hooks
        - static
        - style
        - utils
        - ...

    - fix the naming conventions everywhere and make things generally readable.
    - move things where they belong.
    - delete all providers and HTTP integration endpoints.
    - plug all data holes with constants.
    - implement unified `UserContext` that holds their organizations and badges
    - update home page to uilize `UserContext`

- mason: getting authentication implemented:
    - use the test framework.
    - get the badges returnning only to a specific user 
    - add authentication to all socket connections
        - authentication should be done at the connection level, not message level
